/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
var __webpack_exports__ = {};

// UNUSED EXPORTS: DooHTML, default

;// CONCATENATED MODULE: ./src/js/Doo-Config.js
class DooConfig {
    static DATA_BIND ='bind'
    static TEMPLATE_EXT = '.html'
    static COMPONENT_DIR = '/components'
    static NAME ='DooHTML'
    static TYPE = {DEFAULT:0,ENUM:1,DEEP:2,COMPUTED:3 }
    static MATCH = {ANY:-1,STARTS_WITH:0,EXACT:1}
    static DELIMITER = {'BEG':'{{','END':'}}'}
    static DOCUMENT =  'document'
    static SHADOW = 'shadow'
    static FLEX_BODY = '.fbody'	
    static PAGE_SIZE = 12
    static DATA_STORE='data-store'
    static DATA_KEY='data-key'
    static DATA_SCROLL_CONTAINER='.fbody'
    static DATA_SCROLL_HEADER='.fhead'


}
;// CONCATENATED MODULE: ./src/js/DooX.js
const DooX = {
    'dataSet':{},
    'setData': 
    function(name, dataSet, instanceName = null) {
        name = this.getDataSetName(name)
        this.dataSet[name] = dataSet
        this.refresh(name)

    },
    'getData':
    function(name)  {	
        name = this.getDataSetName(name)
        return this.dataSet[name]
    },		
    'getDataSetName':
    function(name)  {
        if (name && typeof name === 'object') {
            name = Doo.getDataBind(name)
        }
        if (!name) {
            console.log('No dataSet name specified.')
            return null
        } else {	
            if (!this.dataSet[name]) {
                this.dataSet[name] = []
            }
        }	
        return name
    },	
    'prepend':
    function(name, obj) {
        name = this.getDataSetName(name)	
        this.append(name, obj, true)
    },	
    
    'append':
    async function(name, obj, top = null) {
        //TODO this can all be done with splice
        if (Array.isArray(obj)) {
            this.dataSet[name] = top ? obj.concat(Doo.DAO.getData(name)) : Doo.DAO.getData(name).concat(obj) 
        } else {
            name = this.getDataSetName(name) 
            // if (!this.dataSet[name]) {
            // 	this.dataSet[name] = []
            // }
            if (top) {
                Doo.DAO.getData(name).splice(0, 0, obj) 
            } else {
                Doo.DAO.getData(name).push(obj)
            } 	
        }
        this.refresh(name)
    },
    'update':
    function(name, obj, idx) {
        name = this.getDataSetName(name)	
        Doo.DAO.getData(name).splice(idx,1,obj)
        this.refresh(name)
    },
    'remove': 
    function(name, idx) {
        name = this.getDataSetName(name)	
        Doo.DAO.getData(name).splice(idx,1)
        this.refresh(name)
    },
    'dispatch':
    async function(name, doc = document) {
        const subscriber = doc.querySelectorAll("[data-src='" + name +"']")
        for (let i=0, len=subscriber.length; i<len; i++) {
            subscriber[i].setAttribute('doo-refresh', new Date().getTime())
        }
    },

    'refresh':
    async function(name, doc = document) {
        const subscriber = doc.querySelectorAll("[doo-dispatch='" + name +"']")
        for (let i=0, len=subscriber.length; i<len; i++) {
            await subscriber.item(i).render()
        }
    },
    'csvToJson':
    function(csvText) {
        let rows = csvText.split("\n")
        let data = []
        if (rows !== undefined) {
            let rowsLen = rows.length
            let fieldDesc = rows[0].replace(/\r/g, '')
            let cols = fieldDesc.split(",")
            let colLen = cols.length

            if (rows.length > 1) {
                let re = new RegExp('(,)(?=(?:[^"]|"[^"]*")*$)','g')
                for (let i=1;i<rowsLen-1;i++) {
                    let obj={}
                    let rowStr = rows[i].replace(re, '|^|') + '|^|'	
                    let row = rowStr.split('|^|')
                    for (let j=0;j<colLen;j++) {
                        obj[cols[j]] = (row[j]) ? row[j].replace(/"/g, '').trim() : ''
                    }	
                    data.push(obj)
                }	
            }
        }
        return data
    }
}
/* harmony default export */ const js_DooX = (DooX);
;// CONCATENATED MODULE: ./src/js/Doo-Html.js

//import Doo from './doo.html'

//import {  createDooTemplate } from './Doo-Template'

class FieldType {
	constructor(fld, type) {
		this._fld = fld
		this.type = type
		this._func = undefined
		this._parentElem = undefined
		this.$1 = undefined
		this.$2 = undefined
		this.$3 = undefined
		this.$4 = undefined
		this.$5 = undefined

		if (this.type === DooConfig.TYPE.COMPUTED) { 
			this.createComputed()
		}	
	}
	set fld(fld) {this._fld=fld}
	set parentElem(parentElem) {this._parentElem = parentElem} 
	set func(func) {this._func = func}
	get fld() {return this._fld}
	get func() {return this._func}
	//TODO simplyfy use computed columnMap
	createComputed() {
		//TODO create a regEx for more elegant parsing
		let breakParams = this.fld.split('(')
		let computedArr = breakParams[0].split('.').reverse()
		let funcName = computedArr[0]
		// if (Reflect.ownKeys(this.klass).filter(key=>key===funcName).length > 0) {
		// 	this.func = this.klass[funcName]
		// 	if (Doo.$Computed[funcName]) {
		// 		console.log('WARNING: ', 'Overwriting a Doo base Doo.$Computed method is not recommended' );
		// 	}
		// } else if (Doo.$Computed[funcName]) { 	
		// 	this.func = Doo.$Computed[funcName]
		// }
		this.fld = computedArr.length > 1 ? computedArr[1] : undefined
		if (typeof this.func !== 'function') {
			console.log('static ' + funcName + '() is not defined in Doo nor has it been defined as a static function in this component')
			//type = undefined
		}
		let params = breakParams[1].replace(')','')
		if (params && params.length > 0) {
			params = params.split(',')
			for (let k=0,len=params.length;k<len;k++ ) {
				this['$'+(k+1)]= params[k].replace(/'/g,'').replace(/"/g,'')
			}
		}
	} 
}



class DooHTML extends HTMLElement {
	static DAO = DooHTML.DAO
	static get version() {return 'v0.90.1b'}

	static define(klass, alias=null) {
		let name = alias || klass.name.toLowerCase()
		customElements.define('doo-' + name, klass)
	}	
	constructor(pageSize=DooConfig.PAGE_SIZE) {
		super()
		this.PAGE_SIZE = pageSize	
		this.data = {}
		this.place = []
		this.template = undefined	
		this.visibleColumns = []
	}
	//set PAGE_SIZE(pageSize) {this.PAGE_SIZE = pageSize }  // remove handled by props

	static get observedAttributes() {
		return ['doo-refresh','data-key','data-template','bind', 'data-page', 'data-page-size', 'page-size']
	}

	// static get observedAttributes() {
	// 	//		return ['doo-refresh','key','doo-foreach','orientation','doo-dao', 'data-src','implements','doo-db-update','doo-db','doo-theme', Doo.$Config.DATA_BIND,'index','page-size','debug']
	// 			return ['doo-after-render','data-name','data-store','data-doo-refresh','data-use-state','doo-refresh','key','doo-foreach','orientation','doo-dao', 'doo-db-update','doo-db','page-size','debug']
	// 		}


	async attributeChangedCallback(name, oldVal, newVal) {
		
		//TODO do we need length???
		if (newVal.length > 0 && oldVal !== newVal) {
			if (name === 'doo-refresh' && this.dataset.useState) {
				await this.render(this.dataset.useState)
			} else if (name === 'data-use-state') {
				//doo noting yet
			} else if (name ==="doo-refresh") {
				await this.render()
			} else if (name === 'data-store') {
				// let dao = window[this.dataset.store]
				// console.log(dao)
			} else if (name === 'page-size') {
				this.PAGE_SIZE = newVal
			} else if (name === 'doo-after-render') {
				if (typeof newVal === 'function') {
					newVal.call(this)
				}
			} else if (name === 'debug') {
				Doo.debug = true
			}	
		}	
	}
	dooParse(argDataNode, component)  {

		const _getPropertyType = (fld, component) => {
			if (!fld) {
				return new FieldType('', undefined)
			}	
			fld = fld.trim()
		
			let type = DooConfig.TYPE.DEFAULT
			if (fld.indexOf('(') > -1) {
				type = DooConfig.TYPE.COMPUTED 
			 } else { 
				if (fld.indexOf(".") > 0) {
					type = DooConfig.TYPE.DEEP
				} else if (!isNaN(fld)) {
					type = DooConfig.TYPE.ENUM
				}
			}
		
			let fieldType = new FieldType(fld, type)
	
			//TODO this needs to be scooped	
			component.visibleColumns.push(fld) 
			fieldType.parentElem = component.parentElement
			
			return fieldType
		}
		
		const  _xAttr =  ['src', 'selected', 'checked',  'disabled', 'readonly']  

	
		//TODO remove HTML comments
		//TODO replace {{}} in <code></code> and <pre></pre> with escaped "\{\{" 
		//TODO Allow for nested {{templateRoot{{yyy}}zzz}}
		let tplNode = argDataNode.cloneNode(true)
		tplNode.removeAttribute(DooConfig.DATA_BIND)
		//tplNode.removeAttribute('dynamic')
		let htmlStr = tplNode.outerHTML.replace(/\t/g, '').replace(/\n/g, '')
		let orgStr = htmlStr
		//covers checked="false" where browser returns true 
		//TODO: check modern browser to see if it still is an issue
		_xAttr.forEach(item => {
			htmlStr = htmlStr.replace(new RegExp(' ' + item + '="{{(.+)}}"', 'g'), ' doo-' + item + '="{{$1}}"')
		})
		let xHtml = (orgStr === htmlStr)
		// if (window[this.constructor.name] === undefined) {
		//     window[this.constructor.name] = []
		// } 
		//TODO bind(this)
		// let inst =  window[this.constructor.name].length
		// htmlStr = htmlStr.split('="doo.self.').join('="' + this.constructor.name + '[' + inst + '].');
		// htmlStr = htmlStr.split('="self.').join('="' + this.constructor.name + '[' + inst + '].');
		//TODO allow key with no value
		// if (this.getAttribute('key')) {
		// 	htmlStr = htmlStr.split(' key ').join(' key="{{ i() }}" ');
		// }	
		let aHTML = htmlStr.split(DooConfig.DELIMITER.END)
	
		let templateArray = []
		let len = aHTML.length
		let aStr
	
		for (let i=0; i<len; i++) {
			if (DooConfig.DELIMITER.BEG.includes(DooConfig.DELIMITER.BEG)) {
				aStr =  aHTML[i].split(DooConfig.DELIMITER.BEG)
				templateArray.push(aStr[0])	
				if (aStr[1]) {
					templateArray.push(_getPropertyType(aStr[1],component))		
				}	
			}	
		} 
		return {templateArray,xHtml}
	}
	
	initReactiveDataNodes(tplNode) {
		const _getNodeLevel = (dataSetElem) => {
			let level = 0
			while (dataSetElem.parentElement) {
				dataSetElem = dataSetElem.parentElement
				level++
			}
			return level;
		}
	
		this.dataMap = null
		this.flex = null
		if (this.hasAttribute('data-map')) {
			if (this.getAttribute('data-map').indexOf('Doo.reflect') === 0) {
				this.dataMap = Reflect.ownKeys(js_DooX.getData(this.getAttribute(DooConfig.DATA_BIND))[0])
			} else {	
				this.dataMap = this.getAttribute('data-map').split('|')
			}
		}
		if (this.hasAttribute('flex')) {
			this.flex = this.getAttribute('flex').replace('[', '').replace(']', '').split('|')
		}

		const replacer = (match, p1) => {
			if (isNaN(p1)) {
				return this.hasAttribute(p1) ? this.getAttribute(p1) : 
						tplNode.hasAttribute(p1) ? tplNode.getAttribute(p1) : '';
			} else if (this.dataMap.length > 0) {
				return DooConfig.DELIMITER.BEG + this.dataMap[p1-1] + DooConfig.DELIMITER.END 
			}	
		}

		let dynamicNodes = tplNode.content.querySelectorAll('[data-src="${data-map}"]')
		if (dynamicNodes.length > 0) {
			[...dynamicNodes].forEach( dNode => { 
				let colObj = []
				this.dataMap.forEach( (item, i)  => {
					let flexGrow = this.flex[i] === undefined ? 1 : this.flex[i]
					let aItem = item.split(':')
					let label = aItem.length > 1 ? aItem[1]  : aItem[0]  
					let dooJustify = ''
					if (flexGrow.includes(':')) {
						dooJustify = flexGrow.split(':').length > 2 ? 'doo-center' : 'doo-end'
						flexGrow = flexGrow.replace(/:/g,'')
					}
					colObj.push({label: label, fieldName: this.dynamicField(aItem[0]), flex: flexGrow, flexJustify: dooJustify })
				})

				let dHtml = this.htmlParse(dNode, colObj)
				let parentElem = dNode.parentElement
				parentElem.removeChild(dNode)
				parentElem.innerHTML = dHtml + parentElem.innerHTML
			})		
		}

		tplNode.innerHTML = tplNode.innerHTML.replace(/\$\{(.+?)\}/gm, replacer)
		let dSrc = tplNode.content.querySelectorAll('[' +  DooConfig.DATA_BIND + ']');
		[...dSrc].forEach( reactNode  =>  {
			if (!reactNode.hasAttribute('data-src')) {
				let dataSrc = this.hasAttribute('doo-dispatch') ? 'DooX' : 'this.data' 
				reactNode.setAttribute('data-src' , dataSrc)
			}	
		})
		let reactiveElems = tplNode.content.querySelectorAll('[data-src]')
		let len = reactiveElems.length
		let i = 0
		let reactiveElem = [], dataElem, dataSet
		for (i=0;i<len;i++) {
			let key = reactiveElems[i].getAttribute(DooConfig.DATA_BIND)  
			let dataSrc = reactiveElems[i].getAttribute('data-src')
			if (dataSrc) {
//				if (dataSrc === 'DooX') {
					this.setAttribute('doo-dispatch', key)
					dataSet = dataSrc.trim() //DooX.getData(key)
//				} else {
//					dataSet = this.host[dataSrc] // await this.getDataObj(dataSrc, reactiveElems[i] )
//					dataSet = await this.getDataObj(dataSrc, reactiveElems[i] )
//				}
//				this.data[key] = Array.isArray(dataSet) ? dataSet : dataSet[key]
			} 
			if (dataSrc.indexOf('this.parent') === 0) {
				reactiveElems[i].useParent = true
			}

			reactiveElems[i].removeAttribute('data-src')
			reactiveElems[i].level = _getNodeLevel(reactiveElems[i])
			reactiveElem.push(reactiveElems[i])
		}
		this.removeAttribute('data-map')
		this.removeAttribute('flex')
		this.removeAttribute('data-fetch')

		const orderByLevel = (a,b) => {
			return ((a.level === b.level) ? 0 : (a.level > b.level) ? 1 : -1)
		}

		reactiveElem.sort(orderByLevel).reverse()

		for (i=0;i<len;i++) {
			if ('|STYLE|LINK|'.indexOf(`|${reactiveElem[i].tagName}|`) > -1) {
				dataElem = reactiveElem[i]
			} else if (reactiveElem[i].parentElement && (reactiveElems[i].getAttribute(DooConfig.DATA_BIND) === 'void' ||  '|DL|UL|TBODY|THEAD|TFOOT|TR|SELECT|SECTION|'.indexOf(`|${reactiveElem[i].parentElement.tagName}|`) >-1)) {
				//TODO remove slots or elem with doo-static attribute, and put as first child after render 
				dataElem = reactiveElem[i].parentElement
			} else {
				dataElem = document.createElement('data')	
			}
			dataElem.dataKey = reactiveElem[i].getAttribute(DooConfig.DATA_BIND)
			let parsedNode = this.dooParse(reactiveElem[i], this,  this.dataMap)
			dataElem.templateArray = parsedNode.templateArray 	
			dataElem.xHtml = parsedNode.xHtml 	
			dataElem.name = i
			dataElem.level = _getNodeLevel(reactiveElem[i])
			dataElem.useParent = reactiveElem[i].useParent
			dataElem.noRepeat = reactiveElem[i].hasAttribute('data-norepeat')
			if (dataElem.tagName === 'DATA' || dataElem.tagName === 'STYLE' || dataElem.tagName === 'LINK') {
				//TODO allow for templates not to require single root node 
				if (reactiveElem[i].parentElement) {
					reactiveElem[i].parentElement.replaceChild(dataElem, reactiveElem[i])
				} else {
					//TODO consider adding single child node on the fly
					console.log('Warning: Templates should only have one childnode')
					reactiveElem[i].appendChild(dataElem)					
				}	
			}
			this.place.push(dataElem)
		}
		return this.place
	}
	async setContext() {
		//TODO tie this to the Doo object and bind it more elegantly
		// if (!window[this.constructor.name]) {
		// 	window[this.constructor.name] = []
		// }
		// window[this.constructor.name].push(this)
		if (this.childNodes.length >0) {
			if (this.getElementsByTagName('template') && this.getElementsByTagName('template').length > 0) {
				this.removeChild(this.getElementsByTagName('template').item(0))
			}	
		}	
		let context = this.getAttribute('context') || DooConfig.SHADOW 
		if (context === DooConfig.SHADOW) {
			this.componentContainer = this.shadow.host
			this.showComponentContainer(false)
			let currentClasses = this.templateElem.firstElementChild.hasAttribute('class') ? ' ' + this.templateElem.firstElementChild.getAttribute('class') : ''
			let parentClasses = this.hasAttribute('class') ? this.getAttribute('class') + ' ' : ''
			if (parentClasses + currentClasses !== '' && this.templateElem.firstElementChild) {
				this.templateElem.firstElementChild.setAttribute('class', `${parentClasses}${currentClasses}`)
			}
			this.shadow.appendChild(this.templateElem)
		} else if (context === DooConfig.DOCUMENT) {
			this.componentContainer = this.parentElement
			this.showComponentContainer(false)
			this.componentContainer.replaceChild(this.templateElem, this)
		}	
		this.initialHeight = this.shadow.firstElementChild.offsetHeight
	}

	renderNode(place, data, start = 0, pgSize = DooConfig.PAGE_SIZE) {
		const _getItemValue = (item, prop) => {
			if (typeof prop === 'function') {
				return this[prop](item)
			}
			let curValue = item
			try { 
				prop.split('.').forEach(key => curValue = curValue[key])
			} catch(e) {
				console.log('Property not found', prop, JSON.stringify(curValue))
			}
			return curValue
		}
	
		let dataLen = data.length
		,stop = start + pgSize
		,html = []

		if (stop > dataLen) { stop = dataLen }
		for (let i = start; i<stop; i++) {
			for (let j=0, len = place.templateArray.length; j<len; j=j+2) {
				html.push(place.templateArray[j])
				if (place.templateArray[j+1] && place.templateArray[j+1].fld) {
					html.push(_getItemValue(data[i],place.templateArray[j+1].fld))
				}    
			}
		}
		return html.join('')
	}
 
	// _highlight(val, filterVal)  {
	// 	let filterKey = filterVal && filterVal.toLowerCase()
	// 	if (!filterKey || !val) {return val}
	// 	let re = new RegExp(filterKey, "ig")
	// 	let value = val.toString().replace(/&amp;/gi,'&')
	// 	//TODO make <b> configurable
	// 	return value.replace(re, txt => `<b class="doo-find">${txt}</b>`)
	// }


	showComponentContainer(show=true) {
		this.componentContainer.style.visibility = show ? 'visible' : 'hidden'

	}
	renderTable(dataSet=this.data[this.defaultDataSet],target=this.place[0], start=0) {
		let elem = document.createElement('template'),len = dataSet.length, i = len - 1
		elem.innerHTML = this.renderNode(target, dataSet, start , len - start)
		do {
			target.insertBefore(elem.content.removeChild(elem.content.lastElementChild), target.firstElementChild).key = dataSet[i].id
		} while ( --i >=0)
		this.showComponentContainer()
	}
	append(dataSet=this.data[this.defaultDataSet],target=this.place[0], start=0) {
		let elem = document.createElement('template'),len = dataSet.length
		elem.innerHTML = this.renderNode(target, dataSet, start , len - start)
		for (let i=start;i<len;i++) {
			target.appendChild(elem.content.removeChild(elem.content.firstElementChild)).key = dataSet[i].id
		}
		this.showComponentContainer()
	}	

	render(dataSetName=null, page=0, replaceOrAppendRow=null)  {
		if (!this.template) {
			console.log(this.name + ' has no template defined')
			return
		} 
		if (!this.place) {
			console.log('No target set on the component or inside the template. USAGE: set the bind=dataKey or data-src=data-key')
		}
		for (let i=0, len=this.place.length;i<len;i++) {
			if (dataSetName && dataSetName !== this.place[i].dataKey) {
				continue   // TODO other for-eachs that are children of the specified data set proably needs to be re-rendered (needs test scenarios)
			}
			if (page === 0 && this.place[i].tagName !== 'STYLE' && !this.place[i].classList.contains('fhead')) {
				let pg = this.place[i].getAttribute(DooConfig.DATA_BIND) === 'dummy' ? -1 : 0 
				this.place[i].setAttribute("page", pg);
			}	
			let dataKey = this.place[i].dataKey
			//this.getFilteredData(this.place[i].dataKey) ? this.getFilteredData(this.place[i].dataKey) : this.data[this.place[i].dataKey]
			let pageSize = this.place[i].noRepeat ? 1 : this.PAGE_SIZE
			if (replaceOrAppendRow === null) {
				// if (this.place[i].useParent) {
				// 	this.place[i].innerHTML =  this.renderNode(this.place[i], dataKey, parseInt(this.getAttribute('key')) , 1)
				// } else {	
					this.place[i].innerHTML =  this.renderNode(this.place[i], dataKey,  page * this.PAGE_SIZE, pageSize)
				// }	
			} else {
				this.place[i].append(this.renderNode(this.place[i], dataKey,  replaceOrAppendRow, 1))
			}
		}		
		this.showComponentContainer()
		return page	
	}
	async connectedCallback() {
		let context = this.getAttribute('context') || DooConfig.SHADOW 
		this.shadow = context === DooConfig.SHADOW ? this.attachShadow({mode: 'open'}) : document
		if (!this.defaultDataSet && this.getAttribute('bind')) {
			this.defaultDataSet = this.getAttribute('bind')
			//this.scrollTarget = Config.FLEX_BODY
		}	
		let tag = this.constructor.name.toLowerCase()

		if (this.scrollTarget) {
			this.scrollElem = this.shadow.querySelector(this.scrollTarget)
		} 

		this.template = this.getAttribute('template')

		this.templateNode = await this.createDooTemplate(this.template)
		this.templateElem = this.templateNode.content
		this.initReactiveDataNodes(this.templateNode)
		this.setContext()
		if (typeof this.dooAfterRender === 'function') {
			await this.dooAfterRender()
		}
		// if (typeof this.dooAfterRender === 'function') {
		// 	this.setAttribute('doo-after-render', 'dooAfterRender')
		// }
	}
	fetchTemplate(url) {
		return new Promise((resolve, reject) => {
		  const xhr = new XMLHttpRequest()
		  xhr.open("GET", url)
		  xhr.onload = () => resolve(xhr.responseText)
		  xhr.onerror = () => reject(xhr.statusText)
		  xhr.send();
		})
	}
	
	async createDooTemplate(templateIdOrPath) { 
		let tpl = ''
		if (templateIdOrPath.indexOf('#') === 0) {
			tpl =  document.querySelector(templateIdOrPath).outerHTML
		} else {
			tpl = await fetchTemplate(url)
		}
		let elem = document.createElement('div')
		elem.innerHTML = tpl
		if (elem.querySelector('template')) {
			//TODO create ERROR slot or Doo.$Config constant
			elem.innerHTML = elem.querySelector('template') ? tpl : `<template><center><pre>The template you are trying to import does not have a &lt;template&gt tag</pre><div style="color:red">${this.template}</div></enter></template>`
		}
		//TODO check for null pointer
		let importedTemplate = elem.querySelector('template').cloneNode(true)
		importedTemplate.removeAttribute('id')
	
		let templateNode  = document.createElement('template')
		templateNode.innerHTML = importedTemplate.innerHTML
	
		// TODO warn when there are multiple children (maybe not needed, not sure)
		if (!templateNode.content.parentElement) {
			let tplRootNode = document.createElement('section');
			tplRootNode.innerHTML = templateNode.innerHTML
			templateNode.innerHTML = tplRootNode.outerHTML
		}
		
		//TODO implement css="inherit" and use https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot to bring them in
		// if (!shadow && component.getAttribute('css')) {
		//     let cssList = this.getAttribute('css').split(',')
		//     let len = cssList.length 
		//     for (let i=0;i<len;i++) {
		//         let link = document.createElement('link')
		//         link.href = cssList[i]
		//         link.rel = "stylesheet"
		//         //this.templateNode.content.firstElementChild.parentNode.insertBefore(link, this.templateNode.content.firstElementChild)
		//         templateNode.content.firstElementChild.parentNode.insertBefore(link, this.templateNode.content.firstElementChild)
		//     }
		// }
		let templateElem = templateNode.content
	
		let styleNode = templateElem.querySelectorAll('style')
		//TODO support multiple style nodes within the template
		if (styleNode && styleNode.length > 0) {
			templateElem.appendChild(styleNode[0])
		}
		return templateNode
	}
	

}	
if (!window.DooHTML) {
	Doo.X = js_DooX
	DooHTML.Config = DooConfig
	window.Doo = DooHTML
	window.DooHTML = DooHTML
}	
		
DooHTML.define(DooHTML,'html')

/* harmony default export */ const Doo_Html = ((/* unused pure expression or super */ null && (DooHTML))); 


/******/ })()
;